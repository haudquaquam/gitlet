Q: Is one GrowList implementation always better than the others?
A: No, the GrowList runtimes vary for different sizes of input. ArithGrowList is much worse over a large number of values, but it's better with small values.

Q: Why is the runtime for N insertions into a geometrically resizing list a Theta(N) operation?
A: As the number of insertions grows, the intervals between increases in array size also grow. Each operation besides those in which an array size must grow by only 1, so it evens out.

Q: Why is the runtime for N insertions into a arithmetically resizing list a Theta(N^2) operation?
A: Each operation will resize the list by increasing it by 1. Each insertion takes a long time on average.

Q: How does the runtime per operation for the ArithGrowList compare to that of GeomGrowList and JavaGrowList? Specifically look at the non-accumulated plots and describe the trends for how long each operation takes as a function of how many elements have already been inserted in the list.
A: The runtime per operation for ArithGrowList is way larger than that of the other lists. The ArithGrowList takes about N time for each Nth item at minimum, while for the other lists, it only takes 1 time, and a high amount of time very infrequently.

Q: When are there spikes in the per operation runtime graphs for each of the implementations? Do these make sense to you? Hint: some of these should and others might not. Empirical runtime can be quite messy and depends on machine specifics which will be revealed in other subsequent classes like CS61C.
A: For GeomGrowList, there are spikes that occur at 2x the location of the previous spike. This makes sense. Similar for JavaGrowList. There are spikes constantly in ArithGrowList.

Q: Optional: Try changing the code for GeomGrowList to resize by a different factor. How does this effect the theoretical asymptotic runtime? How does this effect the plotted runtime?
A:

Q: Optional: Try changing the code for ArithGrowList to resize by adding a different fixed number of spots in the array. How does this effect the theoretical asymptotic runtime? How does this effect the plotted runtime?
A: